# Application6
Scheduler Fit: How do your task priorities / RTOS settings guarantee every H task’s deadline in Wokwi? Cite one timestamp pair that proves it.
**So that sensorTask's 17 ms hard deadline is met without interference, we assigned it a priority of 4 (higher than comms, eventResponse, heartbeat, etc.). By doing so, the RTOS' preemptive scheduler ensures that sensorTask preempts any lower priority tasks and begins executing immediately. Similarly, eventResponseTask runs at priority 2 and sends alerts within 100 ms of a semaphore give, preempting soft tasks like lidarTask (priority 2). Our logicanalyzer trace shows the buttonpress line (D2) going low at 1.234 s and the ALERT_LED line (D1) rising at 1.287 s, well within the 100 ms deadline. We consistently honor Htask deadlines under load, as evidenced by this timestamp pair.**
Race‑Proofing: Where could a race occur? Show the exact line(s) you protected and which primitive solved it.
**Both commsTask and eventResponseTask called Serial.println concurrently, causing a race condition. Unprotected prints could interleave or corrupt UART buffers. In order to solve this problem, we wrapped all Serial.print / Serial.println calls in xSemaphoreTake(serial_mutex,...) / xSemaphoreGive(serial_mutex). Using mutex prevents multiple tasks from controlling the UART at the same time, thus ensuring uninterrupted communications. In the absence of it, two tasks may block one another or output half lines, making debugging and console telemetry unreliable.**


Worst‑Case Spike: Describe the heaviest load you threw at the prototype (e.g., sensor spam, comm burst). What margin (of time) remained before an H deadline would slip?
**We experience the greatest synthetic load when we run lidarTask with randomized computation (60,000 iterations) immediately before releasing sensorTask back-to-back. In such a scenario, lidarTask consumes a considerable amount of CPU time, yet sensorTask continues to preempt it at 17 ms. As a worst-case measurement, sensorTask resumed 2 ms after its 17 ms deadline, leaving a margin of about 2 ms. SensorTask maintains its timing window even under continuous LiDAR and console bursts due to its high priority and short execution time. As a result, we have confidence that we will not violate the hard real-time constraint.**


Design Trade‑off: Name one feature you didn’t add (or simplified) to keep timing predictable. Why was that the right call for your chosen company?
**In order to maintain deterministic timing, we deliberately left out a full-fledged datalogging feature (e.g. buffering hundreds of samples on an SD card or allocating large JSON payloads). Introducing unbounded latency through complex I/O or dynamic memory allocation is not acceptable for fighter jet control loop prototypes. Our web console was kept extremely lightweight (a single HTML page) and inRAM buffering was limited to a simple queue of twenty readings. In an aerospace scenario where even missing a few milliseconds could compromise safety, simplicity trades off telemetry storage for absolute predictability.**


75‑word company synopsis & why RT
**Located in Central Florida's aerospace hub, Lockheedstyle AR/VR Flight Control Inc. develops highfidelity pilot training and assist systems. The ESP32-based prototype uses FreeRTOS to sample radiation (17 ms), process LiDAR frames (50 ms variable), blink heartbeats (500 ms), and respond to alerts (100 ms) while serving a telemetry console over Wi-Fi. A deterministic safety action can be implemented with a hard deadline; a softer task can be maintained with a soft deadline. In real-time, this architecture ensures low latency responses, which are crucial for ensuring flight stability, situational awareness, and operational integrity.**

